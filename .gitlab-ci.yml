---

stages:
 - pre-test
 - test
 - deploy-beta
 - deploy-production

image: alpine:latest

# Disable the Gradle daemon for Continuous Integration servers as correctness
# is usually a priority over speed in CI environments. Using a fresh
# runtime for each build is more reliable since the runtime is completely
# isolated from any previous builds.
variables:
 POSTGRES_HOST_AUTH_METHOD: trust
 APP_NAME: rare-basket

test:
 stage: test
 image: cimg/openjdk:17.0-browsers
 services:
  - name: postgres:17.6-alpine
    alias: postgres
 tags:
  - openstack
 before_script:
  - sudo apt-get update && sudo apt-get install -y postgresql-client
 script:
  # create the test db before running the tests
  - psql -h postgres -U postgres -f backend/database/setup/setup.sql
  # do not run e2e tests as they rely on keycloak which we can't start easily on gitlab:
  # - starting it as a service does not allow to import the realm data
  # - using docker compose as we do locally or on circleci is not possible using the kaniko image
  # - using another image that does allow to run docker compose (as the docker image) does not allow to run gradle
  - ./gradlew check build -x :frontend:pnpmE2e --no-daemon --parallel
 artifacts:
  paths:
   - backend/build/libs/rare-basket.jar
  expire_in: 1 month
 allow_failure: false

.deploy-to-vm: &deploy-to-vm
 tags:
  - openstack
 retry: 1
 before_script:
  - apk update && apk add openssh
 script:
  # SSH initialization
  - eval $(ssh-agent -s)
  - ssh-add <(echo "${SSH_PRIVATE_KEY}")
  - ssh -o StrictHostKeyChecking=no ${SERVER_USER}@${SERVER_IP} 'echo "Successfully connected on $(hostname)"'
  # Copy jar to the server
  - scp ./backend/build/libs/${APP_NAME}.jar ${SERVER_USER}@${SERVER_IP}:/tmp/${APP_NAME}-${ENV}.jar
  - ssh ${SERVER_USER}@${SERVER_IP} "sudo mv /tmp/${APP_NAME}-${ENV}.jar /opt/bootapp/${APP_NAME}-${ENV}.jar ; sudo chown -R bootapp:bootapp /opt/bootapp/"
  # Restarting service with the updated jar and the according Spring profiles enabled
  - ssh ${SERVER_USER}@${SERVER_IP} "sudo systemctl restart bootapp@${APP_NAME}-${ENV}"
  - eval $(ssh-agent -k)
  - echo "Deploy done. Application should be available at http://${SERVER_IP}:${APP_PORT}/${APP_NAME}"

.variables-beta: &variables-beta
 variables:
  ENV: beta
  APP_PORT: ${PORT_BETA}
  SERVER_IP: ${SERVER_IP_DEV}

.variables-prod: &variables-prod
 variables:
  ENV: prod
  APP_PORT: ${PORT_PROD}
  SERVER_IP: ${SERVER_IP_PROD}

deploy-to-beta:
 stage: deploy-beta
 tags:
  - openstack
 <<: *variables-beta
 <<: *deploy-to-vm
 only:
  changes:
   - backend/src/**/*
   - frontend/**/*
   - .gitlab-ci.yml
  refs:
   - branches
 except:
  refs:
   - master
 allow_failure: false # mandatory to block the execution of the pipeline

deploy-to-prod:
 stage: deploy-production
 tags:
  - openstack
 <<: *variables-prod
 <<: *deploy-to-vm
 only:
  changes:
   - backend/src/**/*
   - frontend/**/*
   - .gitlab-ci.yml
  refs:
   - master
 when: manual
 allow_failure: false
