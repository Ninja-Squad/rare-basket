---

stages:
 - test
 - deploy-beta
 - deploy-staging
 - deploy-production

image: circleci/openjdk:11-browsers
# image: $CI_REGISTRY_IMAGE:latest

# Disable the Gradle daemon for Continuous Integration servers as correctness
# is usually a priority over speed in CI environments. Using a fresh
# runtime for each build is more reliable since the runtime is completely
# isolated from any previous builds.
variables:
 POSTGRES_HOST_AUTH_METHOD: trust
 APP_NAME: rare-basket

test:
 stage: test
 services:
  - name: postgres:12.2-alpine
    alias: postgres
 tags:
  - openstack
 script:
  # I know this looks weird, but apt-get update is consistently failing the first time...
  # running it twice fixes the issue
  - sudo apt-get update || sudo apt-get update
  - sudo apt-get install -y postgresql-client
  # create the test db before running the tests
  - psql -h postgres -U postgres -f backend/database/setup/setup.sql
  - ./gradlew check build --no-daemon --parallel
 artifacts:
  paths:
   - backend/build/libs/rare-basket.jar
  expire_in: 1 month
 cache:
  key: "${CI_COMMIT_REF_NAME}"
  policy: pull-push
  paths:
   - .gradle
   - frontend/.gradle/
   - frontend/node_modules/
 allow_failure: false

build-docker:
  stage: test
  tags:
    - openstack
  image: docker:20.10.8
  services:
    - docker:20.10.8-dind
  script:
    - if [ "${CI_COMMIT_REF_SLUG}" == "master" ] ; then TAG=latest ; else TAG=$CI_COMMIT_REF_SLUG ; fi ;
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - docker build -t $CI_REGISTRY_IMAGE:$TAG .
    - docker push $CI_REGISTRY_IMAGE:$TAG
  allow_failure: true
  only:
    changes:
    - .gitlab-ci.yml
    - DockerFile

.deploy-to-vm: &deploy-to-vm
 tags:
  - openstack
 retry: 1
 script:
  # SSH initialization
  - eval $(ssh-agent -s)
  - ssh-add <(echo "${SSH_PRIVATE_KEY}")
  - ssh -o StrictHostKeyChecking=no ${SERVER_USER}@${SERVER_IP} 'echo "Successfully connected on $(hostname)"'
  # Copy jar to the server
  - scp ./backend/build/libs/${APP_NAME}.jar ${SERVER_USER}@${SERVER_IP}:/tmp/${APP_NAME}-${ENV}.jar
  - ssh ${SERVER_USER}@${SERVER_IP} "sudo mv /tmp/${APP_NAME}-${ENV}.jar /opt/bootapp/${APP_NAME}-${ENV}.jar ; sudo chown -R bootapp:bootapp /opt/bootapp/"
  # Restarting service with the updated jar and the according Spring profiles enabled
  - ssh ${SERVER_USER}@${SERVER_IP} "sudo systemctl restart bootapp@${APP_NAME}-${ENV}"
  - eval $(ssh-agent -k)
  - echo "Deploy done. Application should be available at http://${SERVER_IP}:${APP_PORT}/${APP_CONTEXT}"

.variables-beta: &variables-beta
 variables:
  ENV: beta
  APP_PORT: ${PORT_BETA}
  APP_CONTEXT: ${APP_NAME}-${ENV}
  SERVER_IP: ${SERVER_IP_DEV}

.variables-staging: &variables-staging
 variables:
  ENV: staging
  APP_PORT: ${PORT_STAGING}
  APP_CONTEXT: ${APP_NAME}-${ENV}
  SERVER_IP: ${SERVER_IP_DEV}

.variables-prod: &variables-prod
 variables:
  ENV: prod
  APP_PORT: ${PORT_PROD}
  APP_CONTEXT: ${APP_NAME}
  SERVER_IP: ${SERVER_IP_PROD}

deploy-to-beta:
 stage: deploy-beta
 tags:
  - openstack
 <<: *variables-beta
 <<: *deploy-to-vm
 only:
  changes:
   - backend/src/**/*
   - frontend/**/*
   - .gitlab-ci.yml
  refs:
   - branches
 except:
  refs:
   - master
 allow_failure: false # mandatory to block the execution of the pipeline

deploy-to-staging:
 stage: deploy-staging
 tags:
  - openstack
 <<: *variables-staging
 <<: *deploy-to-vm
 only:
  changes:
   - backend/src/**/*
   - frontend/**/*
   - .gitlab-ci.yml
  refs:
   - branches
 except:
  refs:
   - master
 when: manual

deploy-to-prod:
 stage: deploy-production
 tags:
  - openstack
 <<: *variables-prod
 <<: *deploy-to-vm
 only:
  changes:
   - backend/src/**/*
   - frontend/**/*
   - .gitlab-ci.yml
  refs:
   - master
 when: manual
 allow_failure: false
